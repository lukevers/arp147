// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package math

import (
	"fmt"
	"math"
	"testing"
)

var vf = []float32{
	4.9790119248836735e+00,
	7.7388724745781045e+00,
	-2.7688005719200159e-01,
	-5.0106036182710749e+00,
	9.6362937071984173e+00,
	2.9263772392439646e+00,
	5.2290834314593066e+00,
	2.7279399104360102e+00,
	1.8253080916808550e+00,
	-8.6859247685756013e+00,
}

var vf64 = []float64{
	4.9790119248836735e+00,
	7.7388724745781045e+00,
	-2.7688005719200159e-01,
	-5.0106036182710749e+00,
	9.6362937071984173e+00,
	2.9263772392439646e+00,
	5.2290834314593066e+00,
	2.7279399104360102e+00,
	1.8253080916808550e+00,
	-8.6859247685756013e+00,
}

// The expected results below were computed by the high precision calculators
// at http://keisan.casio.com/.  More exact input values (array vf[], above)
// were obtained by printing them with "%.26f".  The answers were calculated
// to 26 digits (by using the "Digit number" drop-down control of each
// calculator).
var acos = []float32{
	1.0496193445098682683891411e+00,
	6.8584008204381796680593197e-01,
	1.5984878716777262130932513e+00,
	2.0956199416980578753566533e+00,
	2.7053010620363543425881403e-01,
	1.273812155820576608178385e+00,
	1.0205369575791238823114782e+00,
	1.2945003612654115698887836e+00,
	1.3872364383001849486021229e+00,
	2.623151008200072631382227e+00,
}
var acosh = []float32{
	2.4743347004159012494457618e+00,
	2.8576385344292769649802701e+00,
	7.2796961502981066190593175e-01,
	2.4796794418831451156471977e+00,
	3.0552020742306061857212962e+00,
	2.044238592688586588942468e+00,
	2.5158701513104513595766636e+00,
	1.99050839282411638174299e+00,
	1.6988625798424034227205445e+00,
	2.9611454842470387925531875e+00,
}
var asin = []float32{
	5.2117698228502840063214308e-01,
	8.8495624475107870221535222e-01,
	-0.27691544882829616930353112e-01,
	-5.2482361490316109531306665e-01,
	1.3002662205912611792513189e+00,
	2.9698417097432011635405047e-01,
	5.5025936921577267568750358e-01,
	2.762959655294850436213494e-01,
	1.8355988849471172041916134e-01,
	-1.0523546814051760733832452e+00,
}
var asinh = []float32{
	2.3083139297413506341172251e+00,
	2.7435516011574954120533221e+00,
	-2.7345908387810202722079111e-01,
	-2.3145157272104217582864294e+00,
	2.9613651848542041911116485e+00,
	1.7949041801560461362186061e+00,
	2.3564033106207471490733951e+00,
	1.7287118562561185619586013e+00,
	1.3626658049154742879949254e+00,
	-2.8581483353680638970217842e+00,
}
var atan = []float32{
	1.372590262129621651920085e+00,
	1.442290609645298083020664e+00,
	-2.7011324359471758245192595e-01,
	-1.3738077684543379452781531e+00,
	1.4673921193587666049154681e+00,
	1.2415173565870168649117764e+00,
	1.3818396865615168979966498e+00,
	1.2194305844639670701091426e+00,
	1.0696031952318783760193244e+00,
	-1.4561721938838084990898679e+00,
}
var atanh = []float32{
	5.4651164876972968542645503e-01,
	1.0299474840636015926520486e+00,
	-2.7695084640834720379753975e-02,
	-5.5072096760574495988294075e-01,
	1.9943940187708235622920938e+00,
	3.0144861735293010385206003e-01,
	5.8033425392622395300179505e-01,
	2.7987996139119147853691061e-01,
	1.845994758159545390263645e-01,
	-1.3273185453559481761232064e+00,
}
var atan2 = []float32{
	1.1088291730037004444527075e+00,
	9.1218183188715804018797795e-01,
	1.5984772603216203736068915e+00,
	2.0352918654092086637227327e+00,
	8.0391819139044720267356014e-01,
	1.2861075249894661588866752e+00,
	1.0889904479131695712182587e+00,
	1.3044821793397925293797357e+00,
	1.3902530903455392306872261e+00,
	2.2859857424479142655411058e+00,
}
var cbrt = []float32{
	1.7075799841925094446722675e+00,
	1.9779982212970353936691498e+00,
	-6.5177429017779910853339447e-01,
	-1.7111838886544019873338113e+00,
	2.1279920909827937423960472e+00,
	1.4303536770460741452312367e+00,
	1.7357021059106154902341052e+00,
	1.3972633462554328350552916e+00,
	1.2221149580905388454977636e+00,
	-2.0556003730500069110343596e+00,
}
var ceil = []float32{
	5.0000000000000000e+00,
	8.0000000000000000e+00,
	0.0000000000000000e+00,
	-5.0000000000000000e+00,
	1.0000000000000000e+01,
	3.0000000000000000e+00,
	6.0000000000000000e+00,
	3.0000000000000000e+00,
	2.0000000000000000e+00,
	-8.0000000000000000e+00,
}
var copysign = []float32{
	-4.9790119248836735e+00,
	-7.7388724745781045e+00,
	-2.7688005719200159e-01,
	-5.0106036182710749e+00,
	-9.6362937071984173e+00,
	-2.9263772392439646e+00,
	-5.2290834314593066e+00,
	-2.7279399104360102e+00,
	-1.8253080916808550e+00,
	-8.6859247685756013e+00,
}
var cosv = []float32{
	2.63475298602361e-01,
	1.14855072940791e-01,
	9.61912973673557e-01,
	2.93813933025118e-01,
	-9.77713881120759e-01,
	-9.7693042565935e-01,
	4.94008902375588e-01,
	-9.15658663558635e-01,
	-2.51772924428081e-01,
	-7.39241190948892e-01,
}

// Results for 100000 * Pi + vf[i]
var cosLarge = []float32{
	2.3867582671490203405e-01,
	1.1905753649968889296e-01,
	9.5633310962403994537e-01,
	2.9835624747405087298e-01,
	-9.8296143106930289335e-01,
	-9.7601697253784369668e-01,
	4.7150978482389260815e-01,
	-9.0551619528261284575e-01,
	-2.2441695969736097371e-01,
	-7.5053899870848161946e-01,
}
var cosh = []float32{
	7.26688033072528e+01,
	1.14794140797855e+03,
	1.03857679044869e+00,
	7.50009435119379e+01,
	7.65524440408496e+03,
	9.35674970800805e+00,
	9.33135259389935e+01,
	7.6833425943552e+00,
	3.18293714077967e+00,
	2.95950522021254e+03,
}
var erf = []float32{
	5.1865355589148753878703246e-01,
	7.2623876165797640602761476e-01,
	-3.123458671075081752310787e-02,
	-5.2143119438965868095436917e-01,
	8.2704741351883737099370819e-01,
	3.2101768150876236473934e-01,
	5.4039904037284769433568954e-01,
	3.0034702222226788981274126e-01,
	2.0369924339378220334850766e-01,
	-7.8069385702186078201947339e-01,
}
var erfc = []float32{
	4.813464581966400146484375e-01,
	2.73761212825775146484375e-01,
	1.03123462200164794921875e+00,
	1.5214312076568603515625e+00,
	1.7295257747173309326171875e-01,
	6.78982317447662353515625e-01,
	4.59600985050201416015625e-01,
	6.99652969837188720703125e-01,
	7.9630076885223388671875e-01,
	1.78069388866424560546875e+00,
}
var exp = []float32{
	1.4533072575710406226789928e+02,
	2.2958823803947116175550036e+03,
	7.5814542690547059855532552e-01,
	6.6668791114468392913772199e-03,
	1.5310488742855208329274319e+04,
	1.8659908585416776105603276e+01,
	1.8662169344413325688947225e+02,
	1.5301331398641597303367234e+01,
	6.2047062984346075253938579e+00,
	1.6894716415998206962556516e-04,
}
var expm1 = []float32{
	5.105047888192893595915578e-02,
	8.0461997663699741378806607e-02,
	-2.7649709636735166941312603e-03,
	-4.8871433078077682055084807e-02,
	1.0115863951340686721636075e-01,
	2.9696164666984332936028324e-02,
	5.3682146002633136794290891e-02,
	2.7654887829930887427343222e-02,
	1.8420686545459599714469334e-02,
	-8.3193868676546670060112376e-02,
}
var exp2 = []float32{
	3.1537841378210906384538248e+01,
	2.136155007588595537981746e+02,
	8.2537402649490709816149092e-01,
	3.1021162722423271940197509e-02,
	7.9581727785457587742712349e+02,
	7.6019908906834743334002269e+00,
	3.7506884819651517659622186e+01,
	6.6250890394361716673188312e+00,
	3.5438267723557026478431453e+00,
	2.4281537148409249038394364e-03,
}
var fabs = []float32{
	4.9790119248836735e+00,
	7.7388724745781045e+00,
	2.7688005719200159e-01,
	5.0106036182710749e+00,
	9.6362937071984173e+00,
	2.9263772392439646e+00,
	5.2290834314593066e+00,
	2.7279399104360102e+00,
	1.8253080916808550e+00,
	8.6859247685756013e+00,
}
var fdim = []float32{
	4.9790119248836735e+00,
	7.7388724745781045e+00,
	0.0000000000000000e+00,
	0.0000000000000000e+00,
	9.6362937071984173e+00,
	2.9263772392439646e+00,
	5.2290834314593066e+00,
	2.7279399104360102e+00,
	1.8253080916808550e+00,
	0.0000000000000000e+00,
}
var floor = []float32{
	4.0000000000000000e+00,
	7.0000000000000000e+00,
	-1.0000000000000000e+00,
	-6.0000000000000000e+00,
	9.0000000000000000e+00,
	2.0000000000000000e+00,
	5.0000000000000000e+00,
	2.0000000000000000e+00,
	1.0000000000000000e+00,
	-9.0000000000000000e+00,
}
var fmod = []float32{
	4.197597503662109375e-02,
	2.261127471923828125e+00,
	3.231799602508544921875e-02,
	4.989396572113037109375e+00,
	3.637065887451171875e-01,
	1.22086811065673828125e+00,
	4.770916461944580078125e+00,
	1.8161804676055908203125e+00,
	8.734595775604248046875e-01,
	1.314075469970703125e+00,
}

type fi struct {
	f float32
	i int
}

type fi64 struct {
	f float64
	i int
}

var frexp = []fi{
	{6.2237649061045918750e-01, 3},
	{9.6735905932226306250e-01, 3},
	{-5.5376011438400318000e-01, -1},
	{-6.2632545228388436250e-01, 3},
	{6.02268356699901081250e-01, 4},
	{7.3159430981099115000e-01, 2},
	{6.5363542893241332500e-01, 3},
	{6.8198497760900255000e-01, 2},
	{9.1265404584042750000e-01, 1},
	{-5.4287029803597508250e-01, 4},
}
var gamma = []float32{
	2.3254351429269981110792287e+01,
	2.9911541540380953847488854e+03,
	-4.5611543538182068857622653e+00,
	7.719544529409674282760534e-01,
	1.6111866067997779464349151e+05,
	1.8706576101106373588578435e+00,
	3.4082793098825220567960059e+01,
	1.5797338666902833725913524e+00,
	9.3834586393523833347529717e-01,
	-2.0939959735724717571981116e-05,
}
var j0 = []float32{
	-1.844467938232901282891163e-01,
	2.2735365877603547213325896e-01,
	9.8092599382495093696121558e-01,
	-1.7411707573114118541290907e-01,
	-2.1389444564250598146415427e-01,
	-2.3409060583078258876987832e-01,
	-1.002909602106513559105494e-01,
	-1.5466723844241511698349711e-01,
	3.2526502295029169342654995e-01,
	-8.7221203636562022465383848e-03,
}
var j1 = []float32{
	-3.251526499661367974880477e-01,
	1.8935818199701867636797203e-01,
	-1.3711761278347556203272006e-01,
	3.2874863296905637577438597e-01,
	1.3133905922259192511347692e-01,
	3.6602432123751521553245425e-01,
	-3.4436769638909270341287083e-01,
	4.3294816044233463969703735e-01,
	5.8181350527267217120908072e-01,
	-2.7030575528152245290414157e-01,
}
var j2 = []float32{
	5.3837489336729049682617188e-02,
	-1.78416788578033447265625e-01,
	9.5217460766434669494628906e-03,
	4.289591312408447265625e-02,
	2.4115370213985443115234375e-01,
	4.8424589633941650390625e-01,
	-3.1421493738889694213867188e-02,
	4.720849692821502685546875e-01,
	3.1223118305206298828125e-01,
	7.096207141876220703125e-02,
}
var jM3 = []float32{
	-3.68404209613800048828125e-01,
	2.81576693058013916015625e-01,
	4.40100528066977858543396e-04,
	3.629927337169647216796875e-01,
	3.1236808747053146362304688e-02,
	-2.95880615711212158203125e-01,
	-3.203317821025848388671875e-01,
	-2.592737972736358642578125e-01,
	-1.0241334140300750732421875e-01,
	-2.3762665688991546630859375e-01,
}
var lgamma = []fi{
	{3.1464922727696165161148656e+00, 1},
	{8.003414596599100150342565e+00, 1},
	{1.5175757392569559911521537e+00, -1},
	{-2.5882972947898785776033037e-01, 1},
	{1.1989896395355636116164533e+01, 1},
	{6.2629003220826717779345927e-01, 1},
	{3.5287926557279662986843505e+00, 1},
	{4.5725639404784895747368978e-01, 1},
	{-6.3636673060571469218160701e-02, 1},
	{-1.0773851275364004109746929e+01, -1},
}
var log = []float32{
	1.6052314802865166321055312e+00,
	2.0462560087837791122922226e+00,
	-1.2841708786077921100599042e+00,
	1.6115563525319109849931465e+00,
	2.2655365337758568422543703e+00,
	1.0737652404394848471014257e+00,
	1.6542360309925929762187025e+00,
	1.0035466884666275344528685e+00,
	6.0174878620510885429695236e-01,
	2.1617038453838053335687164e+00,
}
var logb = []float32{
	2.0000000000000000e+00,
	2.0000000000000000e+00,
	-2.0000000000000000e+00,
	2.0000000000000000e+00,
	3.0000000000000000e+00,
	1.0000000000000000e+00,
	2.0000000000000000e+00,
	1.0000000000000000e+00,
	0.0000000000000000e+00,
	3.0000000000000000e+00,
}
var log10 = []float32{
	6.9714317406582271274828599e-01,
	8.8867769317616729374265105e-01,
	-5.5770832640021483772585498e-01,
	6.9989003118074055720398974e-01,
	9.8391001516907472534967383e-01,
	4.6633031878238667689018371e-01,
	7.1842558002561984764611225e-01,
	4.3583478913333800752738512e-01,
	2.6133617734085839989788269e-01,
	9.3881605155922687178104979e-01,
}
var log1p = []float32{
	4.8590258594231404420948905e-02,
	7.4540266461778942330695941e-02,
	-2.7726407750915797213731029e-03,
	-5.1404915647360660546638655e-02,
	9.199827797293776143749966e-02,
	2.8843763132367205431760837e-02,
	5.0969535594854696591848864e-02,
	2.6913946956754999234595616e-02,
	1.8088493168990766452042251e-02,
	-9.0865243019217320497027401e-02,
}
var log2 = []float32{
	2.3158594707062190618898251e+00,
	2.9521233862883917703341018e+00,
	-1.8526669502700329984917062e+00,
	2.3249844127278861543568029e+00,
	3.268478366538305087466309e+00,
	1.5491157592596970278166492e+00,
	2.3865580889631732407886495e+00,
	1.447811865817085365540347e+00,
	8.6813999540425116282815557e-01,
	3.118679457227342224364709e+00,
}
var modf = [][2]float32{
	{4.0000000000000000e+00, 9.79012012481689453125e-01},
	{7.0000000000000000e+00, 7.38872528076171875e-01},
	{-0.0000000000000000e+00, -2.768800556659698486328125e-01},
	{-5.0000000000000000e+00, -0.10603427886962890625e-01},
	{9.0000000000000000e+00, 6.362934112548828125e-01},
	{2.0000000000000000e+00, 9.2637729644775390625e-01},
	{5.0000000000000000e+00, 2.29083538055419921875e-01},
	{2.0000000000000000e+00, 7.279398441314697265625e-01},
	{1.0000000000000000e+00, 8.253080844879150390625e-01},
	{-8.0000000000000000e+00, -6.85924530029296875e-01},
}
var nextafter32 = []float32{
	4.979012489318848e+00,
	7.738873004913330e+00,
	-2.768800258636475e-01,
	-5.010602951049805e+00,
	9.636294364929199e+00,
	2.926377534866333e+00,
	5.229084014892578e+00,
	2.727940082550049e+00,
	1.825308203697205e+00,
	-8.685923576354980e+00,
}
var nextafter64 = []float64{
	4.97901192488367438926388786e+00,
	7.73887247457810545370193722e+00,
	-2.7688005719200153853520874e-01,
	-5.01060361827107403343006808e+00,
	9.63629370719841915615688777e+00,
	2.92637723924396508934364647e+00,
	5.22908343145930754047867595e+00,
	2.72793991043601069534929593e+00,
	1.82530809168085528249036997e+00,
	-8.68592476857559958602905681e+00,
}
var pow = []float32{
	9.5282251850256347097456455e+04,
	5.4811606104904279112815857e+07,
	5.2859121901631722639791633e-01,
	9.7588034737492157364617887e-06,
	4.328061380051793098449707e+09,
	8.4406772922806317183130886e+02,
	1.6946637435685587115585804e+05,
	5.3449031987388900688529247e+02,
	6.6881820276793590096531261e+01,
	2.0609880324699824502000062e-09,
}
var remainder = []float32{
	4.197597503662109375e-02,
	2.261127471923828125e+00,
	3.231799602508544921875e-02,
	-2.120685577392578125e-02,
	3.637065887451171875e-01,
	1.22086811065673828125e+00,
	-4.5816707611083984375e-01,
	-9.1175937652587890625e-01,
	8.734595775604248046875e-01,
	1.314075469970703125e+00,
}
var signbit = []bool{
	false,
	false,
	true,
	true,
	false,
	false,
	false,
	false,
	false,
	true,
}
var sinv = []float32{
	-9.64666142780183e-01,
	9.93382258860991e-01,
	-2.73355868930034e-01,
	9.5586263278795e-01,
	-2.09941817329904e-01,
	2.13557822195864e-01,
	-8.69456844457312e-01,
	4.01956728827886e-01,
	9.67786337227868e-01,
	-6.73440763248308e-01,
}

// Results for 100000 * Pi + vf[i]
var sinLarge = []float32{
	-9.7109929963004193442799306e-01,
	9.9288735665362626292562709e-01,
	-2.9227894798772985351931197e-01,
	9.5445458225795265505553289e-01,
	-1.8381192842192853320604229e-01,
	2.1769444025528572606020816e-01,
	-8.8186082961844181049571034e-01,
	4.2431170156018682693144228e-01,
	9.7449321608731220845101006e-01,
	-6.6082615824259705039622759e-01,
}
var sinh = []float32{
	7.2661922449851246597063437e+01,
	1.1479409724161644135165261e+03,
	-2.804313635432240658929004e-01,
	-7.4994276632826483819371788e+01,
	7.6552443387702533073024824e+03,
	9.3031588774087250470756771e+00,
	9.3308167505139735453667527e+01,
	7.617988804286397019893684e+00,
	3.0217691576549396970108319e+00,
	-2.9595050512653774603677448e+03,
}
var tanv = []float32{
	-3.6613153031702778683609267e+00,
	8.6490063819217510854286957e+00,
	-2.8417941790106521215975022e-01,
	3.2532923913660454218188534e+00,
	2.1472725444917167836322847e-01,
	-2.1860085077371774198162768e-01,
	-1.7600023810831588733094577e+00,
	-4.3898097055698959145786375e-01,
	-3.8438856736730442342775405e+00,
	9.1098922989380126669090032e-01,
}

// Results for 100000 * Pi + vf[i]
var tanLarge = []float32{
	-4.0686956571853372111036151e+00,
	8.3395590556018337480281843e+00,
	-3.0562462498305897895534144e-01,
	3.1990433930530146611204145e+00,
	1.8699810858496340726375706e-01,
	-2.2304370352211774775064157e-01,
	-1.8702916842920109807835161e+00,
	-4.6858543642917238614131747e-01,
	-4.3423332060173693847104914e+00,
	8.8046878227479008494071877e-01,
}
var tanh = []float32{
	9.9990531208595156975604823e-01,
	9.9999962057089353262284703e-01,
	-2.7001504955841515442926948e-01,
	-9.9991110939677196878250243e-01,
	9.9999999146797957649823729e-01,
	9.9427249501464587400079154e-01,
	9.9994257602207337054522895e-01,
	9.9149409397456556014560647e-01,
	9.4936501225240998991239394e-01,
	-9.9999994291371308019478192e-01,
}
var trunc = []float32{
	4.0000000000000000e+00,
	7.0000000000000000e+00,
	-0.0000000000000000e+00,
	-5.0000000000000000e+00,
	9.0000000000000000e+00,
	2.0000000000000000e+00,
	5.0000000000000000e+00,
	2.0000000000000000e+00,
	1.0000000000000000e+00,
	-8.0000000000000000e+00,
}
var y0 = []float32{
	-3.053399289507013336653074e-01,
	1.7437228808259341850117607e-01,
	-8.6221781639768590999040043e-01,
	-3.100664606312569793189482e-01,
	1.4222013049283060981409221e-01,
	4.0000038941669685543800483e-01,
	-3.3340750489793041788644246e-01,
	4.5399792324794124853681865e-01,
	4.829000396252861593282546e-01,
	2.7036698405086367902327993e-01,
}
var y1 = []float32{
	1.5494210790144077871666184e-01,
	-2.1659550338223088061795352e-01,
	-2.4644949753915472712151313e+00,
	1.4427411346778715173222452e-01,
	2.2153796076650936197616204e-01,
	3.0388010845747304156105884e-01,
	0.69110727296453455803515453e-01,
	2.3801161746391211182505288e-01,
	-2.0849493408967861851621706e-01,
	0.24250254150277903569810078e-01,
}
var y2 = []float32{
	3.6757802257771909903993901e-01,
	-2.3034827233519228339986284e-01,
	-1.6939678166783799895256379e+01,
	3.6765398099449969615548639e-01,
	-0.96240218650843700753938492e-01,
	-1.9231691071670525827741471e-01,
	3.5984071323873811909521692e-01,
	-2.7949875459806139410545711e-01,
	-7.1134907336544106470910265e-01,
	-2.6478317911071275192469443e-01,
}
var yM3 = []float32{
	-1.4035986900181010583743557e-01,
	-9.7535125271852457506938094e-02,
	2.4225776392533555281261215e+02,
	-1.4922664849496450334420672e-01,
	2.6148702190175382442660634e-01,
	5.6675381370409771975005242e-01,
	-2.0615028975936117161538164e-01,
	6.4784287558250763794376326e-01,
	1.3503631664375164156410847e+00,
	1.461869245393860039516909e-01,
}

// arguments and expected results for special cases
var vfacosSC = []float32{
	-Pi,
	1,
	Pi,
	NaN(),
}
var acosSC = []float32{
	NaN(),
	0,
	NaN(),
	NaN(),
}

var vfacoshSC = []float32{
	Inf(-1),
	0.5,
	1,
	Inf(1),
	NaN(),
}
var acoshSC = []float32{
	NaN(),
	NaN(),
	0,
	Inf(1),
	NaN(),
}

var vfasinSC = []float32{
	-Pi,
	Copysign(0, -1),
	0,
	Pi,
	NaN(),
}
var asinSC = []float32{
	NaN(),
	Copysign(0, -1),
	0,
	NaN(),
	NaN(),
}

var vfasinhSC = []float32{
	Inf(-1),
	Copysign(0, -1),
	0,
	Inf(1),
	NaN(),
}
var asinhSC = []float32{
	Inf(-1),
	Copysign(0, -1),
	0,
	Inf(1),
	NaN(),
}

var vfatanSC = []float32{
	Inf(-1),
	Copysign(0, -1),
	0,
	Inf(1),
	NaN(),
}
var atanSC = []float32{
	-Pi / 2,
	Copysign(0, -1),
	0,
	Pi / 2,
	NaN(),
}

var vfatanhSC = []float32{
	Inf(-1),
	-Pi,
	-1,
	Copysign(0, -1),
	0,
	1,
	Pi,
	Inf(1),
	NaN(),
}
var atanhSC = []float32{
	NaN(),
	NaN(),
	Inf(-1),
	Copysign(0, -1),
	0,
	Inf(1),
	NaN(),
	NaN(),
	NaN(),
}
var vfatan2SC = [][2]float32{
	{Inf(-1), Inf(-1)},
	{Inf(-1), -Pi},
	{Inf(-1), 0},
	{Inf(-1), +Pi},
	{Inf(-1), Inf(1)},
	{Inf(-1), NaN()},
	{-Pi, Inf(-1)},
	{-Pi, 0},
	{-Pi, Inf(1)},
	{-Pi, NaN()},
	{Copysign(0, -1), Inf(-1)},
	{Copysign(0, -1), -Pi},
	{Copysign(0, -1), Copysign(0, -1)},
	{Copysign(0, -1), 0},
	{Copysign(0, -1), +Pi},
	{Copysign(0, -1), Inf(1)},
	{Copysign(0, -1), NaN()},
	{0, Inf(-1)},
	{0, -Pi},
	{0, Copysign(0, -1)},
	{0, 0},
	{0, +Pi},
	{0, Inf(1)},
	{0, NaN()},
	{+Pi, Inf(-1)},
	{+Pi, 0},
	{+Pi, Inf(1)},
	{+Pi, NaN()},
	{Inf(1), Inf(-1)},
	{Inf(1), -Pi},
	{Inf(1), 0},
	{Inf(1), +Pi},
	{Inf(1), Inf(1)},
	{Inf(1), NaN()},
	{NaN(), NaN()},
}
var atan2SC = []float32{
	-3 * Pi / 4,     // atan2(-Inf, -Inf)
	-Pi / 2,         // atan2(-Inf, -Pi)
	-Pi / 2,         // atan2(-Inf, +0)
	-Pi / 2,         // atan2(-Inf, +Pi)
	-Pi / 4,         // atan2(-Inf, +Inf)
	NaN(),           // atan2(-Inf, NaN)
	-Pi,             // atan2(-Pi, -Inf)
	-Pi / 2,         // atan2(-Pi, +0)
	Copysign(0, -1), // atan2(-Pi, Inf)
	NaN(),           // atan2(-Pi, NaN)
	-Pi,             // atan2(-0, -Inf)
	-Pi,             // atan2(-0, -Pi)
	-Pi,             // atan2(-0, -0)
	Copysign(0, -1), // atan2(-0, +0)
	Copysign(0, -1), // atan2(-0, +Pi)
	Copysign(0, -1), // atan2(-0, +Inf)
	NaN(),           // atan2(-0, NaN)
	Pi,              // atan2(+0, -Inf)
	Pi,              // atan2(+0, -Pi)
	Pi,              // atan2(+0, -0)
	0,               // atan2(+0, +0)
	0,               // atan2(+0, +Pi)
	0,               // atan2(+0, +Inf)
	NaN(),           // atan2(+0, NaN)
	Pi,              // atan2(+Pi, -Inf)
	Pi / 2,          // atan2(+Pi, +0)
	0,               // atan2(+Pi, +Inf)
	NaN(),           // atan2(+Pi, NaN)
	3 * Pi / 4,      // atan2(+Inf, -Inf)
	Pi / 2,          // atan2(+Inf, -Pi)
	Pi / 2,          // atan2(+Inf, +0)
	Pi / 2,          // atan2(+Inf, +Pi)
	Pi / 4,          // atan2(+Inf, +Inf)
	NaN(),           // atan2(+Inf, NaN)
	NaN(),           // atan2(NaN, NaN)
}

var vfcbrtSC = []float32{
	Inf(-1),
	Copysign(0, -1),
	0,
	Inf(1),
	NaN(),
}
var cbrtSC = []float32{
	Inf(-1),
	Copysign(0, -1),
	0,
	Inf(1),
	NaN(),
}

var vfceilSC = []float32{
	Inf(-1),
	Copysign(0, -1),
	0,
	Inf(1),
	NaN(),
}
var ceilSC = []float32{
	Inf(-1),
	Copysign(0, -1),
	0,
	Inf(1),
	NaN(),
}

var vfcopysignSC = []float32{
	Inf(-1),
	Inf(1),
	NaN(),
}
var copysignSC = []float32{
	Inf(-1),
	Inf(-1),
	NaN(),
}

var vfcosSC = []float32{
	Inf(-1),
	Inf(1),
	NaN(),
}
var cosSC = []float32{
	NaN(),
	NaN(),
	NaN(),
}

var vfcoshSC = []float32{
	Inf(-1),
	Copysign(0, -1),
	0,
	Inf(1),
	NaN(),
}
var coshSC = []float32{
	Inf(1),
	1,
	1,
	Inf(1),
	NaN(),
}

var vferfSC = []float32{
	Inf(-1),
	Copysign(0, -1),
	0,
	Inf(1),
	NaN(),
}
var erfSC = []float32{
	-1,
	Copysign(0, -1),
	0,
	1,
	NaN(),
}

var vferfcSC = []float32{
	Inf(-1),
	Inf(1),
	NaN(),
}
var erfcSC = []float32{
	2,
	0,
	NaN(),
}

var vfexpSC = []float32{
	Inf(-1),
	-2000,
	2000,
	Inf(1),
	NaN(),
}
var expSC = []float32{
	0,
	0,
	Inf(1),
	Inf(1),
	NaN(),
}

var vfexpm1SC = []float32{
	Inf(-1),
	Copysign(0, -1),
	0,
	Inf(1),
	NaN(),
}
var expm1SC = []float32{
	-1,
	Copysign(0, -1),
	0,
	Inf(1),
	NaN(),
}

var vffabsSC = []float32{
	Inf(-1),
	Copysign(0, -1),
	0,
	Inf(1),
	NaN(),
}
var fabsSC = []float32{
	Inf(1),
	0,
	0,
	Inf(1),
	NaN(),
}

var vffdimSC = [][2]float32{
	{Inf(-1), Inf(-1)},
	{Inf(-1), Inf(1)},
	{Inf(-1), NaN()},
	{Copysign(0, -1), Copysign(0, -1)},
	{Copysign(0, -1), 0},
	{0, Copysign(0, -1)},
	{0, 0},
	{Inf(1), Inf(-1)},
	{Inf(1), Inf(1)},
	{Inf(1), NaN()},
	{NaN(), Inf(-1)},
	{NaN(), Copysign(0, -1)},
	{NaN(), 0},
	{NaN(), Inf(1)},
	{NaN(), NaN()},
}
var fdimSC = []float32{
	NaN(),
	0,
	NaN(),
	0,
	0,
	0,
	0,
	Inf(1),
	NaN(),
	NaN(),
	NaN(),
	NaN(),
	NaN(),
	NaN(),
	NaN(),
}
var fmaxSC = []float32{
	Inf(-1),
	Inf(1),
	NaN(),
	Copysign(0, -1),
	0,
	0,
	0,
	Inf(1),
	Inf(1),
	Inf(1),
	NaN(),
	NaN(),
	NaN(),
	Inf(1),
	NaN(),
}
var fminSC = []float32{
	Inf(-1),
	Inf(-1),
	Inf(-1),
	Copysign(0, -1),
	Copysign(0, -1),
	Copysign(0, -1),
	0,
	Inf(-1),
	Inf(1),
	NaN(),
	Inf(-1),
	NaN(),
	NaN(),
	NaN(),
	NaN(),
}

var vffmodSC = [][2]float32{
	{Inf(-1), Inf(-1)},
	{Inf(-1), -Pi},
	{Inf(-1), 0},
	{Inf(-1), Pi},
	{Inf(-1), Inf(1)},
	{Inf(-1), NaN()},
	{-Pi, Inf(-1)},
	{-Pi, 0},
	{-Pi, Inf(1)},
	{-Pi, NaN()},
	{Copysign(0, -1), Inf(-1)},
	{Copysign(0, -1), 0},
	{Copysign(0, -1), Inf(1)},
	{Copysign(0, -1), NaN()},
	{0, Inf(-1)},
	{0, 0},
	{0, Inf(1)},
	{0, NaN()},
	{Pi, Inf(-1)},
	{Pi, 0},
	{Pi, Inf(1)},
	{Pi, NaN()},
	{Inf(1), Inf(-1)},
	{Inf(1), -Pi},
	{Inf(1), 0},
	{Inf(1), Pi},
	{Inf(1), Inf(1)},
	{Inf(1), NaN()},
	{NaN(), Inf(-1)},
	{NaN(), -Pi},
	{NaN(), 0},
	{NaN(), Pi},
	{NaN(), Inf(1)},
	{NaN(), NaN()},
}
var fmodSC = []float32{
	NaN(),           // fmod(-Inf, -Inf)
	NaN(),           // fmod(-Inf, -Pi)
	NaN(),           // fmod(-Inf, 0)
	NaN(),           // fmod(-Inf, Pi)
	NaN(),           // fmod(-Inf, +Inf)
	NaN(),           // fmod(-Inf, NaN)
	-Pi,             // fmod(-Pi, -Inf)
	NaN(),           // fmod(-Pi, 0)
	-Pi,             // fmod(-Pi, +Inf)
	NaN(),           // fmod(-Pi, NaN)
	Copysign(0, -1), // fmod(-0, -Inf)
	NaN(),           // fmod(-0, 0)
	Copysign(0, -1), // fmod(-0, Inf)
	NaN(),           // fmod(-0, NaN)
	0,               // fmod(0, -Inf)
	NaN(),           // fmod(0, 0)
	0,               // fmod(0, +Inf)
	NaN(),           // fmod(0, NaN)
	Pi,              // fmod(Pi, -Inf)
	NaN(),           // fmod(Pi, 0)
	Pi,              // fmod(Pi, +Inf)
	NaN(),           // fmod(Pi, NaN)
	NaN(),           // fmod(+Inf, -Inf)
	NaN(),           // fmod(+Inf, -Pi)
	NaN(),           // fmod(+Inf, 0)
	NaN(),           // fmod(+Inf, Pi)
	NaN(),           // fmod(+Inf, +Inf)
	NaN(),           // fmod(+Inf, NaN)
	NaN(),           // fmod(NaN, -Inf)
	NaN(),           // fmod(NaN, -Pi)
	NaN(),           // fmod(NaN, 0)
	NaN(),           // fmod(NaN, Pi)
	NaN(),           // fmod(NaN, +Inf)
	NaN(),           // fmod(NaN, NaN)
}

var vffrexpSC = []float32{
	Inf(-1),
	Copysign(0, -1),
	0,
	Inf(1),
	NaN(),
}
var frexpSC = []fi{
	{Inf(-1), 0},
	{Copysign(0, -1), 0},
	{0, 0},
	{Inf(1), 0},
	{NaN(), 0},
}

var vfgammaSC = []float32{
	Inf(-1),
	-3,
	Copysign(0, -1),
	0,
	Inf(1),
	NaN(),
}
var gammaSC = []float32{
	NaN(),
	NaN(),
	Inf(-1),
	Inf(1),
	Inf(1),
	NaN(),
}

var vfhypotSC = [][2]float32{
	{Inf(-1), Inf(-1)},
	{Inf(-1), 0},
	{Inf(-1), Inf(1)},
	{Inf(-1), NaN()},
	{Copysign(0, -1), Copysign(0, -1)},
	{Copysign(0, -1), 0},
	{0, Copysign(0, -1)},
	{0, 0}, // +0, +0
	{0, Inf(-1)},
	{0, Inf(1)},
	{0, NaN()},
	{Inf(1), Inf(-1)},
	{Inf(1), 0},
	{Inf(1), Inf(1)},
	{Inf(1), NaN()},
	{NaN(), Inf(-1)},
	{NaN(), 0},
	{NaN(), Inf(1)},
	{NaN(), NaN()},
}
var hypotSC = []float32{
	Inf(1),
	Inf(1),
	Inf(1),
	Inf(1),
	0,
	0,
	0,
	0,
	Inf(1),
	Inf(1),
	NaN(),
	Inf(1),
	Inf(1),
	Inf(1),
	Inf(1),
	Inf(1),
	NaN(),
	Inf(1),
	NaN(),
}

/*var vfilogbSC = []float32{
	Inf(-1),
	0,
	Inf(1),
	NaN(),
}*/

var ilogbSC = []int{
	MaxInt32,
	MinInt32,
	MaxInt32,
	MaxInt32,
}

var vfj0SC = []float32{
	Inf(-1),
	0,
	Inf(1),
	NaN(),
}
var j0SC = []float32{
	0,
	1,
	0,
	NaN(),
}
var j1SC = []float32{
	0,
	0,
	0,
	NaN(),
}
var j2SC = []float32{
	0,
	0,
	0,
	NaN(),
}
var jM3SC = []float32{
	0,
	0,
	0,
	NaN(),
}

var vfldexpSC = []fi{
	{0, 0},
	{0, -1075},
	{0, 1024},
	{Copysign(0, -1), 0},
	{Copysign(0, -1), -1075},
	{Copysign(0, -1), 1024},
	{Inf(1), 0},
	{Inf(1), -1024},
	{Inf(-1), 0},
	{Inf(-1), -1024},
	{NaN(), -1024},
}
var ldexpSC = []float32{
	0,
	0,
	0,
	Copysign(0, -1),
	Copysign(0, -1),
	Copysign(0, -1),
	Inf(1),
	Inf(1),
	Inf(-1),
	Inf(-1),
	NaN(),
}

var vflgammaSC = []float32{
	Inf(-1),
	-3,
	0,
	1,
	2,
	Inf(1),
	NaN(),
}
var lgammaSC = []fi{
	{Inf(-1), 1},
	{Inf(1), 1},
	{Inf(1), 1},
	{0, 1},
	{0, 1},
	{Inf(1), 1},
	{NaN(), 1},
}

var vflogSC = []float32{
	Inf(-1),
	-Pi,
	Copysign(0, -1),
	0,
	1,
	Inf(1),
	NaN(),
}
var logSC = []float32{
	NaN(),
	NaN(),
	Inf(-1),
	Inf(-1),
	0,
	Inf(1),
	NaN(),
}

var vflogbSC = []float32{
	Inf(-1),
	0,
	Inf(1),
	NaN(),
}
var logbSC = []float32{
	Inf(1),
	Inf(-1),
	Inf(1),
	NaN(),
}

var vflog1pSC = []float32{
	Inf(-1),
	-Pi,
	-1,
	Copysign(0, -1),
	0,
	Inf(1),
	NaN(),
}
var log1pSC = []float32{
	NaN(),
	NaN(),
	Inf(-1),
	Copysign(0, -1),
	0,
	Inf(1),
	NaN(),
}

var vfmodfSC = []float32{
	Inf(-1),
	Inf(1),
	NaN(),
}
var modfSC = [][2]float32{
	{Inf(-1), NaN()}, // [2]float32{Copysign(0, -1), Inf(-1)},
	{Inf(1), NaN()},  // [2]float32{0, Inf(1)},
	{NaN(), NaN()},
}

var vfnextafter32SC = [][2]float32{
	{0, 0},
	{0, float32(Copysign(0, -1))},
	{0, -1},
	{0, float32(NaN())},
	{float32(Copysign(0, -1)), 1},
	{float32(Copysign(0, -1)), 0},
	{float32(Copysign(0, -1)), float32(Copysign(0, -1))},
	{float32(Copysign(0, -1)), -1},
	{float32(NaN()), 0},
	{float32(NaN()), float32(NaN())},
}
var nextafter32SC = []float32{
	0,
	0,
	-1.401298464e-45, // Float32frombits(0x80000001)
	float32(NaN()),
	1.401298464e-45, // Float32frombits(0x00000001)
	float32(Copysign(0, -1)),
	float32(Copysign(0, -1)),
	-1.401298464e-45, // Float32frombits(0x80000001)
	float32(NaN()),
	float32(NaN()),
}

var vfnextafter64SC = [][2]float64{
	{0, 0},
	{0, float64(Copysign(0, -1))},
	{0, -1},
	{0, float64(NaN())},
	{float64(Copysign(0, -1)), 1},
	{float64(Copysign(0, -1)), 0},
	{float64(Copysign(0, -1)), float64(Copysign(0, -1))},
	{float64(Copysign(0, -1)), -1},
	{float64(NaN()), 0},
	{float64(NaN()), float64(NaN())},
}
var nextafter64SC = []float64{
	0,
	0,
	-4.9406564584124654418e-324, // Float64frombits(0x8000000000000001)
	float64(NaN()),
	4.9406564584124654418e-324, // Float64frombits(0x0000000000000001)
	float64(Copysign(0, -1)),
	float64(Copysign(0, -1)),
	-4.9406564584124654418e-324, // Float64frombits(0x8000000000000001)
	float64(NaN()),
	float64(NaN()),
}

var vfpowSC = [][2]float32{
	{Inf(-1), -Pi},
	{Inf(-1), -3},
	{Inf(-1), Copysign(0, -1)},
	{Inf(-1), 0},
	{Inf(-1), 1},
	{Inf(-1), 3},
	{Inf(-1), Pi},
	{Inf(-1), NaN()},

	{-Pi, Inf(-1)},
	{-Pi, -Pi},
	{-Pi, Copysign(0, -1)},
	{-Pi, 0},
	{-Pi, 1},
	{-Pi, Pi},
	{-Pi, Inf(1)},
	{-Pi, NaN()},

	{-1, Inf(-1)},
	{-1, Inf(1)},
	{-1, NaN()},
	{-1 / 2, Inf(-1)},
	{-1 / 2, Inf(1)},
	{Copysign(0, -1), Inf(-1)},
	{Copysign(0, -1), -Pi},
	{Copysign(0, -1), -3},
	{Copysign(0, -1), 3},
	{Copysign(0, -1), Pi},
	{Copysign(0, -1), Inf(1)},

	{0, Inf(-1)},
	{0, -Pi},
	{0, -3},
	{0, Copysign(0, -1)},
	{0, 0},
	{0, 3},
	{0, Pi},
	{0, Inf(1)},
	{0, NaN()},

	{1 / 2, Inf(-1)},
	{1 / 2, Inf(1)},
	{1, Inf(-1)},
	{1, Inf(1)},
	{1, NaN()},

	{Pi, Inf(-1)},
	{Pi, Copysign(0, -1)},
	{Pi, 0},
	{Pi, 1},
	{Pi, Inf(1)},
	{Pi, NaN()},
	{Inf(1), -Pi},
	{Inf(1), Copysign(0, -1)},
	{Inf(1), 0},
	{Inf(1), 1},
	{Inf(1), Pi},
	{Inf(1), NaN()},
	{NaN(), -Pi},
	{NaN(), Copysign(0, -1)},
	{NaN(), 0},
	{NaN(), 1},
	{NaN(), Pi},
	{NaN(), NaN()},
}
var powSC = []float32{
	0,               // pow(-Inf, -Pi)
	Copysign(0, -1), // pow(-Inf, -3)
	1,               // pow(-Inf, -0)
	1,               // pow(-Inf, +0)
	Inf(-1),         // pow(-Inf, 1)
	Inf(-1),         // pow(-Inf, 3)
	Inf(1),          // pow(-Inf, Pi)
	NaN(),           // pow(-Inf, NaN)
	0,               // pow(-Pi, -Inf)
	NaN(),           // pow(-Pi, -Pi)
	1,               // pow(-Pi, -0)
	1,               // pow(-Pi, +0)
	-Pi,             // pow(-Pi, 1)
	NaN(),           // pow(-Pi, Pi)
	Inf(1),          // pow(-Pi, +Inf)
	NaN(),           // pow(-Pi, NaN)
	1,               // pow(-1, -Inf) IEEE 754-2008
	1,               // pow(-1, +Inf) IEEE 754-2008
	NaN(),           // pow(-1, NaN)
	Inf(1),          // pow(-1/2, -Inf)
	0,               // pow(-1/2, +Inf)
	Inf(1),          // pow(-0, -Inf)
	Inf(1),          // pow(-0, -Pi)
	Inf(-1),         // pow(-0, -3) IEEE 754-2008
	Copysign(0, -1), // pow(-0, 3) IEEE 754-2008
	0,               // pow(-0, +Pi)
	0,               // pow(-0, +Inf)
	Inf(1),          // pow(+0, -Inf)
	Inf(1),          // pow(+0, -Pi)
	Inf(1),          // pow(+0, -3)
	1,               // pow(+0, -0)
	1,               // pow(+0, +0)
	0,               // pow(+0, 3)
	0,               // pow(+0, +Pi)
	0,               // pow(+0, +Inf)
	NaN(),           // pow(+0, NaN)
	Inf(1),          // pow(1/2, -Inf)
	0,               // pow(1/2, +Inf)
	1,               // pow(1, -Inf) IEEE 754-2008
	1,               // pow(1, +Inf) IEEE 754-2008
	1,               // pow(1, NaN) IEEE 754-2008
	0,               // pow(+Pi, -Inf)
	1,               // pow(+Pi, -0)
	1,               // pow(+Pi, +0)
	Pi,              // pow(+Pi, 1)
	Inf(1),          // pow(+Pi, +Inf)
	NaN(),           // pow(+Pi, NaN)
	0,               // pow(+Inf, -Pi)
	1,               // pow(+Inf, -0)
	1,               // pow(+Inf, +0)
	Inf(1),          // pow(+Inf, 1)
	Inf(1),          // pow(+Inf, Pi)
	NaN(),           // pow(+Inf, NaN)
	NaN(),           // pow(NaN, -Pi)
	1,               // pow(NaN, -0)
	1,               // pow(NaN, +0)
	NaN(),           // pow(NaN, 1)
	NaN(),           // pow(NaN, +Pi)
	NaN(),           // pow(NaN, NaN)
}

var vfpow10SC = []int{
	MinInt32,
	MaxInt32,
	-325,
	309,
}

var pow10SC = []float32{
	0,      // pow10(MinInt32)
	Inf(1), // pow10(MaxInt32)
	0,      // pow10(-325)
	Inf(1), // pow10(309)
}

var vfsignbitSC = []float32{
	Inf(-1),
	Copysign(0, -1),
	0,
	Inf(1),
	NaN(),
}
var signbitSC = []bool{
	true,
	true,
	false,
	false,
	false,
}

var vfsinSC = []float32{
	Inf(-1),
	Copysign(0, -1),
	0,
	Inf(1),
	NaN(),
}
var sinSC = []float32{
	NaN(),
	Copysign(0, -1),
	0,
	NaN(),
	NaN(),
}

var vfsinhSC = []float32{
	Inf(-1),
	Copysign(0, -1),
	0,
	Inf(1),
	NaN(),
}
var sinhSC = []float32{
	Inf(-1),
	Copysign(0, -1),
	0,
	Inf(1),
	NaN(),
}

var vfsqrtSC = []float32{
	Inf(-1),
	-Pi,
	Copysign(0, -1),
	0,
	Inf(1),
	NaN(),
}
var sqrtSC = []float32{
	NaN(),
	NaN(),
	Copysign(0, -1),
	0,
	Inf(1),
	NaN(),
}

var vftanhSC = []float32{
	Inf(-1),
	Copysign(0, -1),
	0,
	Inf(1),
	NaN(),
}
var tanhSC = []float32{
	-1,
	Copysign(0, -1),
	0,
	1,
	NaN(),
}

var vfy0SC = []float32{
	Inf(-1),
	0,
	Inf(1),
	NaN(),
}
var y0SC = []float32{
	NaN(),
	Inf(-1),
	0,
	NaN(),
}
var y1SC = []float32{
	NaN(),
	Inf(-1),
	0,
	NaN(),
}
var y2SC = []float32{
	NaN(),
	Inf(-1),
	0,
	NaN(),
}
var yM3SC = []float32{
	NaN(),
	Inf(1),
	0,
	NaN(),
}

// arguments and expected results for boundary cases
const (
	SmallestNormalFloat32   = 1.175494351e-38 // 2**-1022
	LargestSubnormalFloat32 = SmallestNormalFloat32 - SmallestNonzeroFloat32
)

var vffrexpBC = []float32{
	SmallestNormalFloat32,
	LargestSubnormalFloat32,
	SmallestNonzeroFloat32,
	MaxFloat32,
	-SmallestNormalFloat32,
	-LargestSubnormalFloat32,
	-SmallestNonzeroFloat32,
	-MaxFloat32,
}
var frexpBC = []fi{
	{0.5, -125},
	{0.99999988079071044921875, -126},
	{0.5, -148},
	{0.999999940395355224609375, 128},
	{-0.5, -125},
	{-0.99999988079071044921875, -126},
	{-0.5, -148},
	{-0.999999940395355224609375, 128},
}

var vfldexpBC = []fi{
	{SmallestNormalFloat32, -23},
	{LargestSubnormalFloat32, -51},
	{SmallestNonzeroFloat32, 149},
	{MaxFloat32, -(1023 + 1074)},
	{1, -150},
	{-1, -150},
	{1, 128},
	{-1, 128},
}
var ldexpBC = []float32{
	SmallestNonzeroFloat32,
	1e-323, // 2**-1073
	1,
	1e-323, // 2**-1073
	0,
	Copysign(0, -1),
	Inf(1),
	Inf(-1),
}

var logbBC = []float32{
	-126,
	-127,
	-149,
	127,
	-126,
	-127,
	-149,
	127,
}

func tolerance(a, b, e float32) bool {
	d := a - b
	if d < 0 {
		d = -d
	}

	if a != 0 {
		e = e * a
		if e < 0 {
			e = -e
		}
	}
	return d < e
}
func closeenough(a, b float32) bool { return tolerance(a, b, 1e-5) }
func kindaclose(a, b float32) bool  { return tolerance(a, b, 1e-8) }  // 1e-8, unused
func close(a, b float32) bool       { return tolerance(a, b, 1e-14) } // 1e-14
func veryclose(a, b float32) bool   { return tolerance(a, b, 4e-16) } // 4e-16
func soclose(a, b, e float32) bool  { return tolerance(a, b, e) }
func alike(a, b float32) bool {
	switch {
	case IsNaN(a) && IsNaN(b):
		return true
	case a == b:
		return Signbit(a) == Signbit(b)
	}
	return false
}

func TestNaN(t *testing.T) {
	t.Parallel()
	f64 := NaN()
	if f64 == f64 {
		t.Fatalf("NaN() returns %g, expected NaN", f64)
	}
	f32 := float32(f64)
	if f32 == f32 {
		t.Fatalf("float32(NaN()) is %g, expected NaN", f32)
	}
}

func TestAcos(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		a := vf[i] / 10
		if f := Acos(a); !close(acos[i], f) {
			t.Errorf("Acos(%g) = %g, want %g", a, f, acos[i])
		}
	}
	for i := 0; i < len(vfacosSC); i++ {
		if f := Acos(vfacosSC[i]); !alike(acosSC[i], f) {
			t.Errorf("Acos(%g) = %g, want %g", vfacosSC[i], f, acosSC[i])
		}
	}
}

func TestAcosh(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		a := 1 + Abs(vf[i])
		if f := Acosh(a); !veryclose(acosh[i], f) {
			t.Errorf("Acosh(%g) = %g, want %g", a, f, acosh[i])
		}
	}
	for i := 0; i < len(vfacoshSC); i++ {
		if f := Acosh(vfacoshSC[i]); !alike(acoshSC[i], f) {
			t.Errorf("Acosh(%g) = %g, want %g", vfacoshSC[i], f, acoshSC[i])
		}
	}
}

func TestAsin(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		a := vf[i] / 10
		if f := Asin(a); !veryclose(asin[i], f) {
			t.Errorf("Asin(%g) = %g, want %g", a, f, asin[i])
		}
	}
	for i := 0; i < len(vfasinSC); i++ {
		if f := Asin(vfasinSC[i]); !alike(asinSC[i], f) {
			t.Errorf("Asin(%g) = %g, want %g", vfasinSC[i], f, asinSC[i])
		}
	}
}

func TestAsinh(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		if f := Asinh(vf[i]); !closeenough(asinh[i], f) {
			t.Errorf("Asinh(%g) = %g, want %g", vf[i], f, asinh[i])
		}
	}
	if f := Asinh(2e20); !closeenough(float32(math.Asinh(2e20)), f) {
		t.Errorf("Asinh(%g) = %g, want %g", 2e20, f, asinh[0])
	}
	for i := 0; i < len(vfasinhSC); i++ {
		if f := Asinh(vfasinhSC[i]); !alike(asinhSC[i], f) {
			t.Errorf("Asinh(%g) = %g, want %g", vfasinhSC[i], f, asinhSC[i])
		}
	}
}

func TestAtan(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		if f := Atan(vf[i]); !veryclose(atan[i], f) {
			t.Errorf("Atan(%g) = %g, want %g", vf[i], f, atan[i])
		}
	}
	for i := 0; i < len(vfatanSC); i++ {
		if f := Atan(vfatanSC[i]); !alike(atanSC[i], f) {
			t.Errorf("Atan(%g) = %g, want %g", vfatanSC[i], f, atanSC[i])
		}
	}
}

func TestAtanh(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		a := vf[i] / 10
		if f := Atanh(a); !veryclose(atanh[i], f) {
			t.Errorf("Atanh(%g) = %g, want %g", a, f, atanh[i])
		}
	}
	for i := 0; i < len(vfatanhSC); i++ {
		if f := Atanh(vfatanhSC[i]); !alike(atanhSC[i], f) {
			t.Errorf("Atanh(%g) = %g, want %g", vfatanhSC[i], f, atanhSC[i])
		}
	}
}

func TestAtan2(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		if f := Atan2(10, vf[i]); !veryclose(atan2[i], f) {
			t.Errorf("Atan2(10, %g) = %g, want %g", vf[i], f, atan2[i])
		}
	}
	for i := 0; i < len(vfatan2SC); i++ {
		if f := Atan2(vfatan2SC[i][0], vfatan2SC[i][1]); !alike(atan2SC[i], f) {
			t.Errorf("Atan2(%g, %g) = %g, want %g", vfatan2SC[i][0], vfatan2SC[i][1], f, atan2SC[i])
		}
	}
}

func TestCbrt(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		if f := Cbrt(vf[i]); !veryclose(cbrt[i], f) {
			t.Errorf("Cbrt(%g) = %g, want %g", vf[i], f, cbrt[i])
		}
	}
	for i := 0; i < len(vfcbrtSC); i++ {
		if f := Cbrt(vfcbrtSC[i]); !alike(cbrtSC[i], f) {
			t.Errorf("Cbrt(%g) = %g, want %g", vfcbrtSC[i], f, cbrtSC[i])
		}
	}
}

func TestCeil(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		if f := Ceil(vf[i]); ceil[i] != f {
			t.Errorf("Ceil(%g) = %g, want %g", vf[i], f, ceil[i])
		}
	}
	for i := 0; i < len(vfceilSC); i++ {
		if f := Ceil(vfceilSC[i]); !alike(ceilSC[i], f) {
			t.Errorf("Ceil(%g) = %g, want %g", vfceilSC[i], f, ceilSC[i])
		}
	}
}

func TestCopysign(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		if f := Copysign(vf[i], -1); copysign[i] != f {
			t.Errorf("Copysign(%g, -1) = %g, want %g", vf[i], f, copysign[i])
		}
	}
	for i := 0; i < len(vf); i++ {
		if f := Copysign(vf[i], 1); -copysign[i] != f {
			t.Errorf("Copysign(%g, 1) = %g, want %g", vf[i], f, -copysign[i])
		}
	}
	for i := 0; i < len(vfcopysignSC); i++ {
		if f := Copysign(vfcopysignSC[i], -1); !alike(copysignSC[i], f) {
			t.Errorf("Copysign(%g, -1) = %g, want %g", vfcopysignSC[i], f, copysignSC[i])
		}
	}
}

func TestCos(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		if f := Cos(vf[i]); !closeenough(cosv[i], f) {
			t.Errorf("[%d] Cos(%g) = %g, want %g", i, vf[i], f, cosv[i])
		}
	}
	for i := 0; i < len(vfcosSC); i++ {
		if f := Cos(vfcosSC[i]); !alike(cosSC[i], f) {
			t.Errorf("Cos(%g) = %g, want %g", vfcosSC[i], f, cosSC[i])
		}
	}
}

func TestCosh(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		if f := Cosh(vf[i]); !closeenough(cosh[i], f) {
			t.Errorf("[%d] Cosh(%g) = %g, want %g", i, vf[i], f, cosh[i])
		}
	}
	for i := 0; i < len(vfcoshSC); i++ {
		if f := Cosh(vfcoshSC[i]); !alike(coshSC[i], f) {
			t.Errorf("Cosh(%g) = %g, want %g", vfcoshSC[i], f, coshSC[i])
		}
	}
}

func TestErf(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		a := vf[i] / 10
		if f := Erf(a); !veryclose(erf[i], f) {
			t.Errorf("Erf(%g) = %g, want %g", a, f, erf[i])
		}
	}
	for i := 0; i < len(vferfSC); i++ {
		if f := Erf(vferfSC[i]); !alike(erfSC[i], f) {
			t.Errorf("Erf(%g) = %g, want %g", vferfSC[i], f, erfSC[i])
		}
	}
}

func TestErfc(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		a := vf[i] / 10
		if f := Erfc(a); !veryclose(erfc[i], f) {
			t.Errorf("[%d] Erfc(%g) = %g, want %g", i, a, f, erfc[i])
		}
	}
	for i := 0; i < len(vferfcSC); i++ {
		if f := Erfc(vferfcSC[i]); !alike(erfcSC[i], f) {
			t.Errorf("Erfc(%g) = %g, want %g", vferfcSC[i], f, erfcSC[i])
		}
	}
}

func TestExp(t *testing.T) {
	t.Parallel()
	testExp(t, Exp, "Exp")
}

func testExp(t *testing.T, Exp func(float32) float32, name string) {
	for i := 0; i < len(vf); i++ {
		if f := Exp(vf[i]); !close(exp[i], f) {
			t.Errorf("%s(%g) = %g, want %g", name, vf[i], f, exp[i])
		}
	}
	for i := 0; i < len(vfexpSC); i++ {
		if f := Exp(vfexpSC[i]); !alike(expSC[i], f) {
			t.Errorf("%s(%g) = %g, want %g", name, vfexpSC[i], f, expSC[i])
		}
	}
}

func TestExpm1(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		a := vf[i] / 100
		if f := Expm1(a); !veryclose(expm1[i], f) {
			t.Errorf("Expm1(%g) = %g, want %g", a, f, expm1[i])
		}
	}
	for i := 0; i < len(vfexpm1SC); i++ {
		if f := Expm1(vfexpm1SC[i]); !alike(expm1SC[i], f) {
			t.Errorf("Expm1(%g) = %g, want %g", vfexpm1SC[i], f, expm1SC[i])
		}
	}
}

func TestExp2(t *testing.T) {
	t.Parallel()
	testExp2(t, Exp2, "Exp2")
}

func testExp2(t *testing.T, Exp2 func(float32) float32, name string) {
	for i := 0; i < len(vf); i++ {
		if f := Exp2(vf[i]); !close(exp2[i], f) {
			t.Errorf("%s(%g) = %g, want %g", name, vf[i], f, exp2[i])
		}
	}
	for i := 0; i < len(vfexpSC); i++ {
		if f := Exp2(vfexpSC[i]); !alike(expSC[i], f) {
			t.Errorf("%s(%g) = %g, want %g", name, vfexpSC[i], f, expSC[i])
		}
	}
	for n := -1074; n < 1024; n++ {
		f := Exp2(float32(n))
		vf := Ldexp(1, n)
		if f != vf {
			t.Errorf("%s(%d) = %g, want %g", name, n, f, vf)
		}
	}
}

func TestAbs(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		if f := Abs(vf[i]); fabs[i] != f {
			t.Errorf("Abs(%g) = %g, want %g", vf[i], f, fabs[i])
		}
	}
	for i := 0; i < len(vffabsSC); i++ {
		if f := Abs(vffabsSC[i]); !alike(fabsSC[i], f) {
			t.Errorf("Abs(%g) = %g, want %g", vffabsSC[i], f, fabsSC[i])
		}
	}
}

func TestDim(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		if f := Dim(vf[i], 0); fdim[i] != f {
			t.Errorf("Dim(%g, %g) = %g, want %g", vf[i], 0.0, f, fdim[i])
		}
	}
	for i := 0; i < len(vffdimSC); i++ {
		if f := Dim(vffdimSC[i][0], vffdimSC[i][1]); !alike(fdimSC[i], f) {
			t.Errorf("Dim(%g, %g) = %g, want %g", vffdimSC[i][0], vffdimSC[i][1], f, fdimSC[i])
		}
	}
}

func TestFloor(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		if f := Floor(vf[i]); floor[i] != f {
			t.Errorf("Floor(%g) = %g, want %g", vf[i], f, floor[i])
		}
	}
	for i := 0; i < len(vfceilSC); i++ {
		if f := Floor(vfceilSC[i]); !alike(ceilSC[i], f) {
			t.Errorf("Floor(%g) = %g, want %g", vfceilSC[i], f, ceilSC[i])
		}
	}
}

func TestMax(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		if f := Max(vf[i], ceil[i]); ceil[i] != f {
			t.Errorf("Max(%g, %g) = %g, want %g", vf[i], ceil[i], f, ceil[i])
		}
	}
	for i := 0; i < len(vffdimSC); i++ {
		if f := Max(vffdimSC[i][0], vffdimSC[i][1]); !alike(fmaxSC[i], f) {
			t.Errorf("Max(%g, %g) = %g, want %g", vffdimSC[i][0], vffdimSC[i][1], f, fmaxSC[i])
		}
	}
}

func TestMin(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		if f := Min(vf[i], floor[i]); floor[i] != f {
			t.Errorf("Min(%g, %g) = %g, want %g", vf[i], floor[i], f, floor[i])
		}
	}
	for i := 0; i < len(vffdimSC); i++ {
		if f := Min(vffdimSC[i][0], vffdimSC[i][1]); !alike(fminSC[i], f) {
			t.Errorf("Min(%g, %g) = %g, want %g", vffdimSC[i][0], vffdimSC[i][1], f, fminSC[i])
		}
	}
}

func TestMod(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		if f := Mod(10, vf[i]); fmod[i] != f {
			t.Errorf("Mod(10, %g) = %g, want %g", vf[i], f, fmod[i])
		}
	}
	for i := 0; i < len(vffmodSC); i++ {
		if f := Mod(vffmodSC[i][0], vffmodSC[i][1]); !alike(fmodSC[i], f) {
			t.Errorf("Mod(%g, %g) = %g, want %g", vffmodSC[i][0], vffmodSC[i][1], f, fmodSC[i])
		}
	}
}

func TestFrexp(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		if f, j := Frexp(vf[i]); !veryclose(frexp[i].f, f) || frexp[i].i != j {
			t.Errorf("Frexp(%g) = %g, %d, want %g, %d", vf[i], f, j, frexp[i].f, frexp[i].i)
		}
	}
	for i := 0; i < len(vffrexpSC); i++ {
		if f, j := Frexp(vffrexpSC[i]); !alike(frexpSC[i].f, f) || frexpSC[i].i != j {
			t.Errorf("Frexp(%g) = %g, %d, want %g, %d", vffrexpSC[i], f, j, frexpSC[i].f, frexpSC[i].i)
		}
	}
	for i := 0; i < len(vffrexpBC); i++ {
		if f, j := Frexp(vffrexpBC[i]); !alike(frexpBC[i].f, f) || frexpBC[i].i != j {
			t.Errorf("Frexp(%g) = %g, %d, want %g, %d", vffrexpBC[i], f, j, frexpBC[i].f, frexpBC[i].i)
		}
	}
}

func TestGamma(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		if f := Gamma(vf[i]); !closeenough(gamma[i], f) {
			t.Errorf("Gamma(%g) = %g, want %g", vf[i], f, gamma[i])
		}
	}
	for i := 0; i < len(vfgammaSC); i++ {
		if f := Gamma(vfgammaSC[i]); !alike(gammaSC[i], f) {
			t.Errorf("Gamma(%g) = %g, want %g", vfgammaSC[i], f, gammaSC[i])
		}
	}
}

func TestHypot(t *testing.T) {
	t.Parallel()
	sqrt2 := Sqrt(2)
	for i := 0; i < len(vf); i++ {
		a := Abs(1e20 * tanh[i] * sqrt2)
		if f := Hypot(1e20*tanh[i], 1e20*tanh[i]); !closeenough(a, f) {
			t.Errorf("[%d] Hypot(%g, %g) = %g, want %g", i, 1e20*tanh[i], 1e20*tanh[i], f, a)
		}
	}
	for i := 0; i < len(vfhypotSC); i++ {
		if f := Hypot(vfhypotSC[i][0], vfhypotSC[i][1]); !alike(hypotSC[i], f) {
			t.Errorf("Hypot(%g, %g) = %g, want %g", vfhypotSC[i][0], vfhypotSC[i][1], f, hypotSC[i])
		}
	}
}

func TestIlogb(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		a := frexp[i].i - 1 // adjust because fr in the interval [Â½, 1)
		if e := Ilogb(vf[i]); a != e {
			t.Errorf("Ilogb(%g) = %d, want %d", vf[i], e, a)
		}
	}
	for i := 0; i < len(vflogbSC); i++ {
		if e := Ilogb(vflogbSC[i]); ilogbSC[i] != e {
			t.Errorf("Ilogb(%g) = %d, want %d", vflogbSC[i], e, ilogbSC[i])
		}
	}
	for i := 0; i < len(vffrexpBC); i++ {
		if e := Ilogb(vffrexpBC[i]); int(logbBC[i]) != e {
			t.Errorf("Ilogb(%g) = %d, want %d", vffrexpBC[i], e, int(logbBC[i]))
		}
	}
}

func TestJ0(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		if f := J0(vf[i]); !soclose(j0[i], f, 4e-14) {
			t.Errorf("J0(%g) = %g, want %g", vf[i], f, j0[i])
		}
	}
	for i := 0; i < len(vfj0SC); i++ {
		if f := J0(vfj0SC[i]); !alike(j0SC[i], f) {
			t.Errorf("J0(%g) = %g, want %g", vfj0SC[i], f, j0SC[i])
		}
	}
}

func TestJ1(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		if f := J1(vf[i]); !close(j1[i], f) {
			t.Errorf("J1(%g) = %g, want %g", vf[i], f, j1[i])
		}
	}
	for i := 0; i < len(vfj0SC); i++ {
		if f := J1(vfj0SC[i]); !alike(j1SC[i], f) {
			t.Errorf("J1(%g) = %g, want %g", vfj0SC[i], f, j1SC[i])
		}
	}
}

func TestJn(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		if f := Jn(2, vf[i]); !closeenough(j2[i], f) {
			t.Errorf("[%d] Jn(2, %g) = %g, want %g", i, vf[i], f, j2[i])
		}
		if f := Jn(-3, vf[i]); !closeenough(jM3[i], f) {
			t.Errorf("[%d] Jn(-3, %g) = %g, want %g", i, vf[i], f, jM3[i])
		}
	}
	for i := 0; i < len(vfj0SC); i++ {
		if f := Jn(2, vfj0SC[i]); !alike(j2SC[i], f) {
			t.Errorf("Jn(2, %g) = %g, want %g", vfj0SC[i], f, j2SC[i])
		}
		if f := Jn(-3, vfj0SC[i]); !alike(jM3SC[i], f) {
			t.Errorf("Jn(-3, %g) = %g, want %g", vfj0SC[i], f, jM3SC[i])
		}
	}
}

func TestLdexp(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		if f := Ldexp(frexp[i].f, frexp[i].i); !veryclose(vf[i], f) {
			t.Errorf("Ldexp(%g, %d) = %g, want %g", frexp[i].f, frexp[i].i, f, vf[i])
		}
	}
	for i := 0; i < len(vffrexpSC); i++ {
		if f := Ldexp(frexpSC[i].f, frexpSC[i].i); !alike(vffrexpSC[i], f) {
			t.Errorf("Ldexp(%g, %d) = %g, want %g", frexpSC[i].f, frexpSC[i].i, f, vffrexpSC[i])
		}
	}
	for i := 0; i < len(vfldexpSC); i++ {
		if f := Ldexp(vfldexpSC[i].f, vfldexpSC[i].i); !alike(ldexpSC[i], f) {
			t.Errorf("Ldexp(%g, %d) = %g, want %g", vfldexpSC[i].f, vfldexpSC[i].i, f, ldexpSC[i])
		}
	}
	for i := 0; i < len(vffrexpBC); i++ {
		if f := Ldexp(frexpBC[i].f, frexpBC[i].i); !alike(vffrexpBC[i], f) {
			t.Errorf("Ldexp(%g, %d) = %g, want %g", frexpBC[i].f, frexpBC[i].i, f, vffrexpBC[i])
		}
	}
	for i := 0; i < len(vfldexpBC); i++ {
		if f := Ldexp(vfldexpBC[i].f, vfldexpBC[i].i); !alike(ldexpBC[i], f) {
			t.Errorf("[%d] Ldexp(%g, %d) = %g, want %g", i, vfldexpBC[i].f, vfldexpBC[i].i, f, ldexpBC[i])
		}
	}
}

func TestLgamma(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		if f, s := Lgamma(vf[i]); !closeenough(lgamma[i].f, f) || lgamma[i].i != s {
			t.Errorf("Lgamma(%g) = %g, %d, want %g, %d", vf[i], f, s, lgamma[i].f, lgamma[i].i)
		}
	}
	for i := 0; i < len(vflgammaSC); i++ {
		if f, s := Lgamma(vflgammaSC[i]); !alike(lgammaSC[i].f, f) || lgammaSC[i].i != s {
			t.Errorf("Lgamma(%g) = %g, %d, want %g, %d", vflgammaSC[i], f, s, lgammaSC[i].f, lgammaSC[i].i)
		}
	}
}

func TestLog(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		a := Abs(vf[i])
		if f := Log(a); log[i] != f {
			t.Errorf("Log(%g) = %g, want %g", a, f, log[i])
		}
	}
	if f := Log(10); f != Ln10 {
		t.Errorf("Log(%g) = %g, want %g", 10.0, f, Ln10)
	}
	for i := 0; i < len(vflogSC); i++ {
		if f := Log(vflogSC[i]); !alike(logSC[i], f) {
			t.Errorf("Log(%g) = %g, want %g", vflogSC[i], f, logSC[i])
		}
	}
}

func TestLogb(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		if f := Logb(vf[i]); logb[i] != f {
			t.Errorf("Logb(%g) = %g, want %g", vf[i], f, logb[i])
		}
	}
	for i := 0; i < len(vflogbSC); i++ {
		if f := Logb(vflogbSC[i]); !alike(logbSC[i], f) {
			t.Errorf("Logb(%g) = %g, want %g", vflogbSC[i], f, logbSC[i])
		}
	}
	for i := 0; i < len(vffrexpBC); i++ {
		if f := Logb(vffrexpBC[i]); !alike(logbBC[i], f) {
			t.Errorf("Logb(%g) = %g, want %g", vffrexpBC[i], f, logbBC[i])
		}
	}
}

func TestLog10(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		a := Abs(vf[i])
		if f := Log10(a); !veryclose(log10[i], f) {
			t.Errorf("[%d] Log10(%g) = %g, want %g", i, a, f, log10[i])
		}
	}
	if f := Log10(E); !veryclose(Log10Ef, f) {
		t.Errorf("Log10(%g) = %g, want %g", E, f, Log10Ef)
	}
	for i := 0; i < len(vflogSC); i++ {
		if f := Log10(vflogSC[i]); !alike(logSC[i], f) {
			t.Errorf("Log10(%g) = %g, want %g", vflogSC[i], f, logSC[i])
		}
	}
}

func TestLog1p(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		a := vf[i] / 100
		if f := Log1p(a); !closeenough(log1p[i], f) {
			t.Errorf("Log1p(%g) = %g, want %g", a, f, log1p[i])
		}
	}
	a := float32(9.0)
	if f := Log1p(a); f != Ln10 {
		t.Errorf("Log1p(%g) = %g, want %g", a, f, Ln10)
	}
	for i := 0; i < len(vflogSC); i++ {
		if f := Log1p(vflog1pSC[i]); !alike(log1pSC[i], f) {
			t.Errorf("Log1p(%g) = %g, want %g", vflog1pSC[i], f, log1pSC[i])
		}
	}
}

func TestLog2(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		a := Abs(vf[i])
		if f := Log2(a); !veryclose(log2[i], f) {
			t.Errorf("Log2(%g) = %g, want %g", a, f, log2[i])
		}
	}
	if f := Log2(E); f != Log2E {
		t.Errorf("Log2(%g) = %g, want %g", E, f, Log2E)
	}
	for i := 0; i < len(vflogSC); i++ {
		if f := Log2(vflogSC[i]); !alike(logSC[i], f) {
			t.Errorf("Log2(%g) = %g, want %g", vflogSC[i], f, logSC[i])
		}
	}
	for i := -149; i <= 127; i++ {
		f := Ldexp(1, i)
		l := Log2(f)
		if l != float32(i) {
			t.Errorf("Log2(2**%d) = %g, want %d", i, l, i)
		}
	}
}

func TestModf(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		if f, g := Modf(vf[i]); !veryclose(modf[i][0], f) || !veryclose(modf[i][1], g) {
			t.Errorf("Modf(%g) = %g, %g, want %g, %g", vf[i], f, g, modf[i][0], modf[i][1])
		}
	}
	for i := 0; i < len(vfmodfSC); i++ {
		if f, g := Modf(vfmodfSC[i]); !alike(modfSC[i][0], f) || !alike(modfSC[i][1], g) {
			t.Errorf("Modf(%g) = %g, %g, want %g, %g", vfmodfSC[i], f, g, modfSC[i][0], modfSC[i][1])
		}
	}
}

func TestNextafter32(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		vfi := float32(vf[i])
		if f := Nextafter(vfi, 10); nextafter32[i] != f {
			t.Errorf("Nextafter32(%g, %g) = %g want %g", vfi, 10.0, f, nextafter32[i])
		}
	}
	for i := 0; i < len(vfnextafter32SC); i++ {
		if f := Nextafter(vfnextafter32SC[i][0], vfnextafter32SC[i][1]); !alike(nextafter32SC[i], f) {
			t.Errorf("Nextafter32(%g, %g) = %g want %g", vfnextafter32SC[i][0], vfnextafter32SC[i][1], f, nextafter32SC[i])
		}
	}
}

func TestNextafter64(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf64); i++ {
		if f := Nextafter64(vf64[i], 10); nextafter64[i] != f {
			t.Errorf("Nextafter64(%g, %g) = %g want %g", vf64[i], 10.0, f, nextafter64[i])
		}
	}
	for i := 0; i < len(vfnextafter64SC); i++ {
		if f := Nextafter64(vfnextafter64SC[i][0], vfnextafter64SC[i][1]); !alike(float32(nextafter64SC[i]), float32(f)) {
			t.Errorf("Nextafter64(%g, %g) = %g want %g", vfnextafter64SC[i][0], vfnextafter64SC[i][1], f, nextafter64SC[i])
		}
	}
}

func TestPow(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		if f := Pow(10, vf[i]); !closeenough(pow[i], f) {
			t.Errorf("Pow(10, %g) = %g, want %g", vf[i], f, pow[i])
		}
	}
	if f := Pow(10, 0.5); !closeenough(float32(math.Pow(10, 0.5)), f) {
		t.Errorf("Pow(10, %g) = %g, want %g", Pow(10, 0.5), f, float32(math.Pow(10, 0.5)))
	}
	if f := Pow(10, -0.5); !closeenough(float32(math.Pow(10, -0.5)), f) {
		t.Errorf("Pow(10, %g) = %g, want %g", Pow(10, -0.5), f, float32(math.Pow(10, -0.5)))
	}
	for i := 0; i < len(vfpowSC); i++ {
		if f := Pow(vfpowSC[i][0], vfpowSC[i][1]); !alike(powSC[i], f) {
			t.Errorf("Pow(%g, %g) = %g, want %g", vfpowSC[i][0], vfpowSC[i][1], f, powSC[i])
		}
	}
}

func TestPow10(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vfpow10SC); i++ {
		if f := Pow10(vfpow10SC[i]); !alike(pow10SC[i], f) {
			t.Errorf("Pow10(%d) = %g, want %g", vfpow10SC[i], f, pow10SC[i])
		}
	}
	if f := Pow10(-1); !alike(float32(math.Pow10(-1)), f) {
		t.Errorf("Pow10(%d) = %g, want %g", -1, f, float32(math.Pow10(-1)))
	}
}

func TestRemainder(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		if f := Remainder(10, vf[i]); remainder[i] != f {
			t.Errorf("Remainder(10, %g) = %g, want %g", vf[i], f, remainder[i])
		}
	}
	for i := 0; i < len(vffmodSC); i++ {
		if f := Remainder(vffmodSC[i][0], vffmodSC[i][1]); !alike(fmodSC[i], f) {
			t.Errorf("Remainder(%g, %g) = %g, want %g", vffmodSC[i][0], vffmodSC[i][1], f, fmodSC[i])
		}
		if f := Pow(10, 1e20); !closeenough(float32(math.Pow(10, 1e20)), f) {
			t.Errorf("Pow(10, %g) = %g, want %g", Pow(10, 1e20), f, float32(math.Pow(10, 1e20)))
		}
	}
}

func TestSignbit(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		if f := Signbit(vf[i]); signbit[i] != f {
			t.Errorf("Signbit(%g) = %t, want %t", vf[i], f, signbit[i])
		}
	}
	for i := 0; i < len(vfsignbitSC); i++ {
		if f := Signbit(vfsignbitSC[i]); signbitSC[i] != f {
			t.Errorf("Signbit(%g) = %t, want %t", vfsignbitSC[i], f, signbitSC[i])
		}
	}
}
func TestSin(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		if f := Sin(vf[i]); !closeenough(sinv[i], f) {
			t.Errorf("[%d] Sin(%.14f) = %.14f, want %.14f", i, vf[i], f, sinv[i])
		}
	}
	for i := 0; i < len(vfsinSC); i++ {
		if f := Sin(vfsinSC[i]); !alike(sinSC[i], f) {
			t.Errorf("Sin(%.14f) = %.14f, want %.14f", vfsinSC[i], f, sinSC[i])
		}
	}
}

func TestSincos(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		if s, c := Sincos(vf[i]); !veryclose(sinv[i], s) || !veryclose(cosv[i], c) {
			t.Errorf("Sincos(%g) = %g, %g want %g, %g", vf[i], s, c, sinv[i], cosv[i])
		}
	}
}

func TestSinh(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		if f := Sinh(vf[i]); !closeenough(sinh[i], f) {
			t.Errorf("Sinh(%g) = %g, want %g", vf[i], f, sinh[i])
		}
	}
	for i := 0; i < len(vfsinhSC); i++ {
		if f := Sinh(vfsinhSC[i]); !alike(sinhSC[i], f) {
			t.Errorf("Sinh(%g) = %g, want %g", vfsinhSC[i], f, sinhSC[i])
		}
	}
}

func TestTan(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		if f := Tan(vf[i]); !veryclose(tanv[i], f) {
			t.Errorf("Tan(%g) = %g, want %g", vf[i], f, tanv[i])
		}
	}
	// same special cases as Sin
	for i := 0; i < len(vfsinSC); i++ {
		if f := Tan(vfsinSC[i]); !alike(sinSC[i], f) {
			t.Errorf("Tan(%g) = %g, want %g", vfsinSC[i], f, sinSC[i])
		}
	}
}

func TestTanh(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		if f := Tanh(vf[i]); !veryclose(tanh[i], f) {
			t.Errorf("Tanh(%g) = %g, want %g", vf[i], f, tanh[i])
		}
	}
	for i := 0; i < len(vftanhSC); i++ {
		if f := Tanh(vftanhSC[i]); !alike(tanhSC[i], f) {
			t.Errorf("Tanh(%g) = %g, want %g", vftanhSC[i], f, tanhSC[i])
		}
	}
}

func TestTrunc(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		if f := Trunc(vf[i]); trunc[i] != f {
			t.Errorf("Trunc(%g) = %g, want %g", vf[i], f, trunc[i])
		}
	}
	for i := 0; i < len(vfceilSC); i++ {
		if f := Trunc(vfceilSC[i]); !alike(ceilSC[i], f) {
			t.Errorf("Trunc(%g) = %g, want %g", vfceilSC[i], f, ceilSC[i])
		}
	}
}

func TestY0(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		a := Abs(vf[i])
		if f := Y0(a); !close(y0[i], f) {
			t.Errorf("Y0(%g) = %g, want %g", a, f, y0[i])
		}
	}
	for i := 0; i < len(vfy0SC); i++ {
		if f := Y0(vfy0SC[i]); !alike(y0SC[i], f) {
			t.Errorf("Y0(%g) = %g, want %g", vfy0SC[i], f, y0SC[i])
		}
	}
}

func TestY1(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		a := Abs(vf[i])
		if f := Y1(a); !soclose(y1[i], f, 2e-14) {
			t.Errorf("Y1(%g) = %g, want %g", a, f, y1[i])
		}
	}
	for i := 0; i < len(vfy0SC); i++ {
		if f := Y1(vfy0SC[i]); !alike(y1SC[i], f) {
			t.Errorf("Y1(%g) = %g, want %g", vfy0SC[i], f, y1SC[i])
		}
	}
}

func TestYn(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf); i++ {
		a := Abs(vf[i])
		if f := Yn(2, a); !close(y2[i], f) {
			t.Errorf("Yn(2, %g) = %g, want %g", a, f, y2[i])
		}
		if f := Yn(-3, a); !close(yM3[i], f) {
			t.Errorf("Yn(-3, %g) = %g, want %g", a, f, yM3[i])
		}
	}
	for i := 0; i < len(vfy0SC); i++ {
		if f := Yn(2, vfy0SC[i]); !alike(y2SC[i], f) {
			t.Errorf("Yn(2, %g) = %g, want %g", vfy0SC[i], f, y2SC[i])
		}
		if f := Yn(-3, vfy0SC[i]); !alike(yM3SC[i], f) {
			t.Errorf("Yn(-3, %g) = %g, want %g", vfy0SC[i], f, yM3SC[i])
		}
	}
}

// Check that math functions of high angle values
// return accurate results. [Since (vf[i] + large) - large != vf[i],
// testing for Trig(vf[i] + large) == Trig(vf[i]), where large is
// a multiple of 2*Pi, is misleading.]
func TestLargeCos(t *testing.T) {
	t.Parallel()
	t.Skip()
	large := float32(100000 * Pi)
	for i := 0; i < len(vf); i++ {
		f1 := cosLarge[i]
		f2 := Cos(vf[i] + large)
		if !close(f1, f2) {
			t.Errorf("Cos(%g) = %g, want %g", vf[i]+large, f2, f1)
		}
	}
}

func TestLargeSin(t *testing.T) {
	t.Parallel()
	t.Skip()
	large := float32(100000 * Pi)
	for i := 0; i < len(vf); i++ {
		f1 := sinLarge[i]
		f2 := Sin(vf[i] + large)
		if !close(f1, f2) {
			t.Errorf("Sin(%g) = %g, want %g", vf[i]+large, f2, f1)
		}
	}
}

func TestLargeSincos(t *testing.T) {
	t.Parallel()
	large := float32(100000 * Pi)
	for i := 0; i < len(vf); i++ {
		f1, g1 := sinLarge[i], cosLarge[i]
		f2, g2 := Sincos(vf[i] + large)
		if !close(f1, f2) || !close(g1, g2) {
			t.Errorf("Sincos(%g) = %g, %g, want %g, %g", vf[i]+large, f2, g2, f1, g1)
		}
	}
}

func TestLargeTan(t *testing.T) {
	t.Parallel()
	large := float32(100000 * Pi)
	for i := 0; i < len(vf); i++ {
		f1 := tanLarge[i]
		f2 := Tan(vf[i] + large)
		if !close(f1, f2) {
			t.Errorf("Tan(%g) = %g, want %g", vf[i]+large, f2, f1)
		}
	}
}

func TestBit64Conversion(t *testing.T) {
	t.Parallel()
	for i := 0; i < len(vf64); i++ {
		if f := Float64frombits(Float64bits(vf64[i])); f != vf64[i] {
			t.Errorf("Float64frombits(Float64bits(%f)) = %f, want %f", vf64[i], f, vf64[i])
		}
	}
}

// Check that math constants are accepted by compiler
// and have right value (assumes strconv.ParseFloat works).
// http://code.google.com/p/go/issues/detail?id=201

type floatTest struct {
	val  interface{}
	name string
	str  string
}

var floatTests = []floatTest{
	{float64(MaxFloat64), "MaxFloat64", "1.7976931348623157e+308"},
	{float64(SmallestNonzeroFloat64), "SmallestNonzeroFloat64", "5e-324"},
	{float32(MaxFloat32), "MaxFloat32", "3.4028235e+38"},
	{float32(SmallestNonzeroFloat32), "SmallestNonzeroFloat32", "1e-45"},
}

func TestFloatMinMax(t *testing.T) {
	t.Parallel()
	for _, tt := range floatTests {
		s := fmt.Sprint(tt.val)
		if s != tt.str {
			t.Errorf("Sprint(%v) = %s, want %s", tt.name, s, tt.str)
		}
	}
}

// Benchmarks

func BenchmarkAcos(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Acos(.5)
	}
}

func BenchmarkAcosh(b *testing.B) {
	x := float32(1.5)
	for i := 0; i < b.N; i++ {
		Acosh(x)
	}
}

func BenchmarkAcosh64(b *testing.B) {
	x := 1.5
	for i := 0; i < b.N; i++ {
		math.Acosh(x)
	}
}

func BenchmarkAcosh64Cast(b *testing.B) {
	x := float32(1.5)
	for i := 0; i < b.N; i++ {
		_ = float32(math.Acosh(float64(x)))
	}
}

func BenchmarkAsin(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Asin(.5)
	}
}

func BenchmarkAsinh(b *testing.B) {
	x := float32(.5)
	for i := 0; i < b.N; i++ {
		Asinh(x)
	}
}

func BenchmarkAsinhCast(b *testing.B) {
	x := float32(.5)
	for i := 0; i < b.N; i++ {
		_ = float32(math.Asinh(float64(x)))
	}
}

func BenchmarkAsinh64(b *testing.B) {
	x := .5
	for i := 0; i < b.N; i++ {
		math.Asinh(x)
	}
}

func BenchmarkAtan(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Atan(.5)
	}
}

func BenchmarkAtanh(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Atanh(.5)
	}
}

func BenchmarkAtan2(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Atan2(.5, 1)
	}
}

func BenchmarkCbrt(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Cbrt(10)
	}
}

func BenchmarkCeil(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Ceil(.5)
	}
}

func BenchmarkCopysign(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Copysign(.5, -1)
	}
}

func BenchmarkCos(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Cos(.5)
	}
}

func BenchmarkCosh(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Cosh(2.5)
	}
}

func BenchmarkErf(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Erf(.5)
	}
}

func BenchmarkErfc(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Erfc(.5)
	}
}

func BenchmarkExp(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Exp(.5)
	}
}

func BenchmarkExpm1(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Expm1(.5)
	}
}

func BenchmarkExp2(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Exp2(.5)
	}
}

func BenchmarkAbs(b *testing.B) {
	x := float32(.5)
	for i := 0; i < b.N; i++ {
		Abs(x)
	}
}

func BenchmarkAbs64(b *testing.B) {
	x := .5
	for i := 0; i < b.N; i++ {
		math.Abs(x)
	}
}

func BenchmarkAbs64Cast(b *testing.B) {
	x := .5
	for i := 0; i < b.N; i++ {
		_ = float32(math.Abs(float64(x)))
	}
}

func BenchmarkDim(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Dim(10, 3)
	}
}

func BenchmarkFloor(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Floor(.5)
	}
}

func BenchmarkMax(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Max(10, 3)
	}
}

func BenchmarkMin(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Min(10, 3)
	}
}

func BenchmarkMod(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Mod(10, 3)
	}
}

func BenchmarkFrexp(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Frexp(8)
	}
}

func BenchmarkGamma(b *testing.B) {
	x := float32(2.5)
	for i := 0; i < b.N; i++ {
		Gamma(x)
	}
}

func BenchmarkGammaCast(b *testing.B) {
	x := float32(2.5)
	for i := 0; i < b.N; i++ {
		_ = float32(math.Gamma(float64(x)))
	}
}

func BenchmarkGamma64(b *testing.B) {
	x := 2.5
	for i := 0; i < b.N; i++ {
		math.Gamma(x)
	}
}

func BenchmarkHypot(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Hypot(3, 4)
	}
}

func BenchmarkIlogb(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Ilogb(.5)
	}
}

func BenchmarkJ0(b *testing.B) {
	for i := 0; i < b.N; i++ {
		J0(2.5)
	}
}

func BenchmarkJ1(b *testing.B) {
	for i := 0; i < b.N; i++ {
		J1(2.5)
	}
}

func BenchmarkJn(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Jn(2, 2.5)
	}
}

func BenchmarkLdexp(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Ldexp(.5, 2)
	}
}

func BenchmarkLgamma(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Lgamma(2.5)
	}
}

func BenchmarkLog(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Log(.5)
	}
}

func BenchmarkLogb(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Logb(.5)
	}
}

func BenchmarkLog1p(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Log1p(.5)
	}
}

func BenchmarkLog10(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Log10(.5)
	}
}

func BenchmarkLog2(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Log2(.5)
	}
}

func BenchmarkModf(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Modf(1.5)
	}
}

func BenchmarkNextafter32(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Nextafter(.5, 1)
	}
}

func BenchmarkNextafter64(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Nextafter64(.5, 1)
	}
}

func BenchmarkPowInt(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Pow(2, 2)
	}
}

func BenchmarkPowFrac(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Pow(2.5, 1.5)
	}
}

func BenchmarkPow10Pos(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Pow10(300)
	}
}

func BenchmarkPow10Neg(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Pow10(-300)
	}
}

func BenchmarkRemainder(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Remainder(10, 3)
	}
}

func BenchmarkSignbit(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Signbit(2.5)
	}
}

func BenchmarkSin(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Sin(.5)
	}
}

func BenchmarkSincos(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Sincos(.5)
	}
}

func BenchmarkSinh(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Sinh(2.5)
	}
}

func BenchmarkSqrt(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Sqrt(10)
	}
}

func BenchmarkSqrt64(b *testing.B) {
	for i := 0; i < b.N; i++ {
		math.Sqrt(10)
	}
}

func BenchmarkSqrt64Cast(b *testing.B) {
	x := 10.0
	for i := 0; i < b.N; i++ {
		_ = float32(math.Sqrt(float64(x)))
	}
}

func BenchmarkTan(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Tan(.5)
	}
}

func BenchmarkTanh(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Tanh(2.5)
	}
}
func BenchmarkTrunc(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Trunc(.5)
	}
}

func BenchmarkY0(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Y0(2.5)
	}
}

func BenchmarkY1(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Y1(2.5)
	}
}

func BenchmarkYn(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Yn(2, 2.5)
	}
}
